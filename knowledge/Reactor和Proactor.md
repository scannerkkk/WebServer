### Reactor和Proactor

##### 背景：

如果要让服务器服务多个客户端，那么最直接得方式是为每一条连接创建线程，然后处理完业务逻辑后，连接就会被销毁。

1.如果此时有大量客户端呢？毫无疑问会导致服务特别慢。那要怎么解决这个问题？我们可以采用资源复用得方式，直接创建一个线程池，每次将连接分配给线程，然后一个线程可以处理多个业务。

2.不过线程一般采用read->业务处理->send，如果当前连接没有数据可读，那么线程就会阻塞在read上面，但是引用线程池之后，由于线程在某处被阻塞，就不能处理其他连接得业务吗，因此要采用非阻塞得IO，然后用线程不断轮询调用read看是否有数据，因为轮询是要消耗CPU得，因此连接越多，效率越低。

3.那怎么改善这个问题呢？我们采用IO多路复用技术，这个技术会用一个系统调用函数来监听我们所有关心得连接，也就说可以在一个监控线程里面监控很多得连接。



##### select/poll/epoll是如何获取网络连接得？

在获取事件时，先把我们要关心得连接传给内核，再有内核检测：

1.如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面得线程池方案那样轮询调用read操作来判断是否有数据。

2.如果有事件发生，内核就会返回产生了事件得连接，线程就会从阻塞返回，然后在用户态再处理这些连接对应得业务即可。



基于面向对象得思想，于是对I/O多路复用作了一层封装，让使用者不用考虑底层网络API得细节，因此叫做Reactor模式，也叫Dispatcher模式。

Reactor模式主要由Reactor和处理资源池这两个核心部分组成

1.Reactor负责监听和分发事件，事件类型包含连接事件、读写事件。

2.处理资源池负责处理事件，如read->业务逻辑->send。



##### Proactor

1.Reactor是非阻塞同步网络模式，Proactor是异步网络模式。

2.Reactor感知得是就绪可读写事件，即来了事件操作系统通知应用程序，让应用程序处理。

Proactor感知的是已完成得读写事件，即来了事件操作系统来处理，处理完再通知应用进程。



不过linux下得异步IO是不完善得，aio系列函数是由POSIX定义得异步操作接口，不是真正的操作系统级别支持得，而是在用户空间模拟出来得异步，所以Linux得高性能网络程序都是使用Reactor方案。



##### Reactor

实现方案：

第一种方案单 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis 采用的是单 Reactor 单进程的方案。



第二种方案单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。



第三种方案多 Reactor 多进程 / 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor，Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案，Nginx 则采用了类似于 「多 Reactor 多进程」的方案。