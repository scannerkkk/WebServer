### Buffer

##### 1.为什么要设计应用层Buffer？

非阻塞IO得核心思想是避免阻塞在read()和write()或者其他IO系统调用上，这样就可以最大限度地复用线程，让一个线程可以为多个socket连接服务，这样一来，应用层缓冲区是必要的。

##### 2.什么情况下需要输出Buffer呢？

假设TCP连接发过来100K数据，在执行write()时，由于某些影响，操作系统只能读80K数据，那么剩下20K我们要怎么办呢？是阻塞在这里知道操作系统读完？那显然太浪费资源了，万一阻塞很久那就完全没必要了。针对这个问题我们使用一个Buffer来解决，把那些暂时无法接受地数据先存到Buffer中，然后注册POLLOUT事件，一旦socket变得可写就立刻发送数据，如果20K数据写完了，立即停止这个事件，避免造成busy -loop，那如果没写完，此时的数据就应该追加到Buffer数据尾部中。

##### 3.什么情况下需要输入Buffer呢？

TCP是一个无边界的字节流协议，接收方必须要处理收到的数据尚不构成一条完整信息的情况，也叫粘包问题。我们在处理socket可读事件时，必须一次把socket数据读完，负责会反复触发POLLIN事件（epoll的LT模式），造成主循环busy-loop，但是我们如果一次把socket数据读完，就没办法保证数据完整性了，因此我们先把数据全部存到Buffer中，然后根据应用程协议判断是否是一个完整的包，如果是，则通知业务程序，这样就可以提高速度。

##### 4.如何设计Buffer呢？

一方面我们希望系统减少调用，一次读的数据越多越划算。另一方面，我们又希望减少内存，如果有10000个并发连接，每个连接都分配50K的读写缓存区，那么就会产生1G内存。使用栈上空间即可解决这个问题。



底层默认会有一个1KB大小的vector，除此之外，muduo在栈上会申请一个64KB大小的临时空间，当网络套接字数据太大时，可以将超过1KB的数据先放入这个临时空间，然后追加到Buffer里面。