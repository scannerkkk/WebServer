存储映射（memory map）简称mmap，是直接将实际存储的物理地址映射到进程空间，而不使用read/write函数。这样，可以省去中间繁杂调用过程, 快速对文件进行大量输入输出。

mmap() 用于申请一段内存空间，将一个文件或Posix共享内存区对象映射到进程的地址空间；munmap() 释放由mmap创建的这段内存空间。二者是实现存储映射的关键。

mmap函数奖一个文件或者其他对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。
mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。

mmap()是以PAGE_SIZE为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。

注意：用mmap时，open()不可省，read()/write()可省。

常见使用场景

1. **实现共享内存**：进程通过mmap映射相同的文件，实现共享内存方式的通信。
2. **提高传输效率**：对于大量频繁读写的文件，mmap相对read/write的方式，避免了内核空间->用户空间的数据传输和切换，一定程度上提升了数据传输的效率。
3. **复杂数据结构的load/save**：例如机器学习领域经常会有一些比较复杂的模型，通过mmap映射文件到内存空间的方式，低成本的实现模型的load/save。
4. **实现各种懒加载场景**：mmap默认映射的是虚拟内存空间，可以低成本的实现懒加载策略，比如动态链接库等等。



start： 映射区的开始地址，设置为0时表示由系统决定映射区的起始地址。
length： 映射区的长度。//长度单位是 以字节为单位，不足一内存页按一内存页处理
prot： 期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起

PROT_EXEC //页内容可以被执行
PROT_READ //页内容可以被读取
PROT_WRITE //页可以被写入
PROT_NONE //页不可访问

flags： 指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体

MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
MAP_SHARED //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。
MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。
MAP_DENYWRITE //这个标志被忽略。
MAP_EXECUTABLE //同上
MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。
MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。
MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。
MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。
MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。
MAP_FILE //兼容标志，被忽略。
MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。
MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。
MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。

fd： 有效的文件描述词。一般是由open()函数返回，其值也可以设置为-1，此时需要指定flags参数中的MAP_ANON,表明进行的是匿名映射。
off_toffset： 被映射对象内容的起点。



munmap执行相反的操作，删除特定地址区域的对象映射，基于文件的映射，在mmap和munmap执行过程的任何时刻，被映射文件的st_atime可能被更新。

[Linux高级I/O函数 mmap, munmap - 明明1109 - 博客园 (cnblogs.com)](https://www.cnblogs.com/fortunely/p/16212027.html)